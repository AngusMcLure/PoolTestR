---
title: "PoolTestRPaper"
author: "AngusMcLure"
date: "05/06/2020"
output:
  word_document: default
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache.extra = R.version.string)
knitr::opts_chunk$set(cache.extra = R.version)
library(PoolTestR)
library(dplyr)
```
### The PoolTestR Package

The `PoolTestR` package has been designed to be a simple, user-friendly and extensible way to work with data from tests on pooled samples. The package has four primary functions for the estimation of prevalence, `PoolPrev`, `HierPoolPrev`, `PoolReg`, and `PoolRegBayes`. `PoolPrev` produces unadjusted estimates of prevalence of a marker based on the outcome of tests on pooled samples, optionally stratifying the dataset by one or more covariates.   `HierPoolPrev` is like `PoolPrev`  but allows users to adjust prevalence estimates for hierarchical structure in sampling frames. `PoolReg` and `PoolRegBayes` provide flexible and extensible frameworks to fit mixed or fixed effect regression models in either a frquentist or a bayesian framework, allowing users to identify temporal trends or variables associated with higher prevalence and to account for hierarchical sampling frames[^1]. Table 1 provides an overview of the differences between the  four main functions.The following sections provide more details of these functions, Boxes X-Y provide example code, and Figures A-B compare the outputs of these functions when applied to a synthetic dataset.

[^1]: example of people doing this - though it's not clear what model/software they used: Subramanian-2020-Molecular xenomonitoring as a post-MDA surveillance tool for global programme to eliminate lymphatic filariasis- Field validation in an evaluation unit in India

| Function       | Example function call                                        | Are prevalence estimates stratified or adjusted for covariates? | Do the prevalence estimates account for the hierarchical sampling frame? | Bayesian / Frequentist | Output class  |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------- | ------------- |
| `PoolPrev`     | `PoolPrev(Data, Result, NumInPool)`                          | Neither                                                      | No                                                           | Both                   | `tibble`      |
|                | `PoolPrev(Data, Result, NumInPool, Cov1, Cov2)`              | Stratified                                                   | No                                                           | Both                   | `tibble`      |
| `HierPoolPrev` | `PoolPrev(Data, Result, NumInPool, c('Level1', 'Level2'))`   | Neither                                                      | Yes                                                          | Bayesian               | `tibble`      |
|                | `PoolPrev(Data, Result, NumInPool, c('Level1', 'Level2'), Cov1, Cov2)` | Stratified                                                   | Yes                                                          | Bayesian               | `tibble`      |
| `PoolReg`      | `PoolReg(Result ~ Cov1 + Cov2, Data, NumInPool)`             | Adjusted                                                     | No                                                           | Frequentist            | `glmfit` \*   |
|                | `PoolReg(Result ~ Cov1 + Cov2 + (1 | Level1 / Level2), Data, NumInPool)` | Adjusted                                                     | Yes                                                          | Frequentist            | `glmerMod` \* |
| `PoolRegBayes` | `PoolRegBayes(Result ~ Cov1 + Cov2, Data, NumInPool)`        | Adjusted                                                     | No                                                           | Bayesian               | `brmsfit`\*   |
|                | `PoolRegBayes(Result ~ Cov1 + Cov2 + (1 | Level1 / Level2), Data, NumInPool)` | Adjusted                                                     | Yes                                                          | Bayesian               | `brmsfit`\*   |

**Table 1** A summary of the four main functions in PoolTestR, with example function calls applied to a hypothetical dataset called `Data` with columns: `NumInPool` (number of specimens in each pool), `Result` (1/0 result of test for each pool), `Cov1` and `Cov2` (two covariate variables),  and `Level1` and `Level2` (variables identifying sample location at two levels of the sampling frame hierarchy; e.g. village ID and site ID). \* Applying the function `getPrevalence` to these outputs extracts the prevalance for each unique combination of covariates and sampling sites into a list of one or more `tibble`s .

### PoolPrev

`PoolPrev` was designed to produce comparable results to the popular stand-alone application PoolScreen [ref Katholi1996] for familiarity to existing users of the software. Stratifying a dataset and calculating prevalence for each subgroup of the data using PoolScreen requires many manual steps to import data, run analyses and export results. Using `PoolPrev` this can be achieved in a few lines of R code with a simple syntax. This is achieved by utilising non-standard evaluation and tools for working with grouped datasets provided in the `R` package, `dplyr`. 

Given a dataset containing the number of samples and the result of tests for each pool, `PoolPrev` returns Bayesian and maximum likelihood estimates of the prevalence together with uncertainty intervals. Efficient Bayesian inference is performed with Hamiltonian Markov Chain Monte Carlo using the Stan programming language and the `rstan` package. Users can specify their prior belief for the prevalence from the Beta distribution, or use the uninformative 'Jefferey's' prior i.e. $Beta(0.5,0.5)$. Users can also optionally specify the prior probability that the marker of interest is entirely absent from the population, in which case `PoolPrev` also returns the probability of absence given the data. As we assume the test performed on the pooled samples does not produce false positive or negatives, the probability of absence is always zero if any of the pools test positive. In most cases the credible interval (CrI) for the prevalence are the 2.5% and 97.5% quantiles of the posterior distribution. However, if all tests are positive the upper bound of the CrI is 1 and the lower bound is the 5% quantile of the posterior. Similarly, if all tests are negative the lower bound of the CrI is 0 and the lower bound is the 95% quantile of the posterior.
The uncertainty interval for the maximum likelihood estimate is calculated using the likelihood ratio method (i.e. a Wilkâ€™s confidence interval). As with the Bayesian credible interval, the lower or upper bound of the confidence intervals are zero or one when all pools are negative or positive, respectively.

Box A demonstrates the use of `PoolPrev` on a synthetic dataset.

```{r PoolPrevExample, warning=FALSE, cache=TRUE}
#Looking at the first few rows of the synthetic dataset to see structure
head(ExampleData)
#Prevalence across the whole synthetic dataset (ignoring hierarchical sampling)
Prevs <- PoolPrev(ExampleData, Result, NumInPool)
#Prevalence for each Region (ignoring hierarchical sampling)
PrevsRegion <- PoolPrev(ExampleData, Result, NumInPool, Region) 
#Prevalence for each Year (ignoring hierarchical sampling)
PrevsYear <- PoolPrev(ExampleData, Result, NumInPool, Year)
#Prevalence for each combination of Region and Year (ignoring hierarchical sampling)
PrevsYearRegion <- PoolPrev(ExampleData, Result, NumInPool, Region, Year)
PrevsYearRegion

#Prevalence for each Region and Year accounting for hierarchical sampling
HierPrevsYearRegion <- HierPoolPrev(ExampleData, Result, NumInPool,
																		c("Village", "Site"), Region, Year)
#Similar to the above, but estimates prevalence, statifying down to village level
HierPrevsYearRegionVillage <- HierPoolPrev(ExampleData, Result, NumInPool,
																					 c("Site"), Region, Year, Village)
```

### HierPoolPrev
Many xenomonitoring surveys involve a hierarchical sampling structure. For instance if one wishes to understand the prevalence in a particular village, one may place traps at a number of sites around the village. The vectors caught at each site can then be tested individually or in pools. However, as prevalence may vary from site to site, the result of tests on individuals vectors or pools from the same site cannot be considered independent. However, the function `PoolPrev` in our package and other software like PoolScreen assume that results of pools are independent. Estimating the prevalence for the whole village ignoring this dependance will result in over-confident (narrow) estimation intervals. To account for this dependance we can use a hierarchical model. 

`HeirPoolPrev` fits an intercept-only hierarchical generalised linear mixed model with a logistic link function. The syntax and outputs are very similar to `PoolPrev`. There is only one additional argument, `hierarchy`, describing the hierachical structure of the sampling frame. The output provides the Bayesian posterior mean and credible intervals for the prevalence, but unlike `PoolPrev` does not provide the maximum-likelihood estimate or likelihood ratio confidence intervals. As with `PoolPrev` users can specify variables that stratify the dataset into subgroups. If subgroups of the data are specified, estimation proceeds independantly for each subgroup.

Box B demonstrates the use of `HierPoolPrev` on a synthetic dataset. 

### Regression - PoolReg and PoolReg Bayes
Our package provides tools for mixed-effect regression models in both a frequentist and Bayesian framework. `PoolReg` fits a frequentist mixed- or fixed-effect generalised linear model that adjusts for the sizes of pools,  building on `glm` from the in the `stats` package for fixed-effect models and the `glmer` function from the `lme4` package for mixed-effect models. For a model with only fixed effects the output is a S3-object of class `glmfit`, while the output for a model with random effects is a S3-object of class `glmerMod` which supports that same methods (e.g. summary, predict, plot, confint) as any other object returned by the `glm` or `glmer` functions. `PoolRegBayes` provides functionality to perform the same analyses in a Bayesian framework and returns a `brmsfit` object. By building on these existing statistical packages, `PoolTestR` leverages the extensive suite of diagnostics tools available for working with models fitted with these functions and uses paradigms that will be familiar to existing users of `R`. In addition, `PoolTestR` inlcudes the function `getPrevalence`, which provides a convenient way to extract estimates of prevalence from regression models fitted with `PoolReg` or `PoolRegBayes`. The function`getPrevalence`, is able to detect whether a model includes adjustements for hierarchical random/group effect terms, and automatically estimate prevalence at every level of the sampling hierarchy.

Box B applies `PoolReg` and `PoolRegBayes`to the same synthetic dataset used to demonstrate `PoolPrev`, estimating the trend of decline in prevalence over time.

```{r PoolLogitRegExample, warning=FALSE, cache=TRUE}
# Logistic regression model - no adjustment for sampling frame hierarchy
ModFreq <- PoolReg(Result ~ Region + Year,
                   ExampleData, NumInPool)
summary(ModFreq)
# Logistic regression model - adjusting for sampling frame hierarchy
ModFreqHier <- PoolReg(Result ~ Region + Year + (1|Village/Site),
                       ExampleData, NumInPool)
summary(ModFreqHier)
```
```{r PoolLogitRegBayesExample, eval = FALSE}
# Same as above but in a Bayesian framework
ModBayes <- PoolRegBayes(Result ~ Region + Year,
                         ExampleData, NumInPool)
ModBayesHier <- PoolRegBayes(Result ~ Region + Year + (1|Village/Site),
                             ExampleData, NumInPool)
```
```{r HierExample, warning = FALSE, cache = TRUE}
# A more complex model: estimate temporal trend for each village
ModBayesHier2 <- PoolRegBayes(Result ~ Region + Year + (1 + Year|Village) + (1|Site),
                              ExampleData, NumInPool)
# We can use each of these models to estimate prevalence e.g.
getPrevalence(ModFreq)
# For hierarchical models getPrevalence returns prevalence at every level
getPrevalence(ModBayesHier2)

# We can also predict prevalence for new datapoints. For example, this projects
# the temporal trend forward to estimate prevalence in region A in years 3-5.
PredictData <- data.frame(Region = "A", Year = c(3,4,5))
getPrevalence(ModFreq, newdata = PredictData)
```

### Comparison of methods on a synthetic dataset

`PoolTestR` provides a number of approaches to estimate prevalence: frequentist or Bayesian, stratifying or adjusting for covariates, adjusting for or ignoring hierarchical sampling frame (Table 1). We compare the approaches with another synthetic dataset with a realistic hierarchical sampling design.

We simulate samples taken from across three regions (A, B, and C) in which the vectors have a low (0.5\%), medium (2\%), and high (4\%) prevalence of the marker of interest. Within each region we choose ten villages, and within each of these villages we choose ten sites to place traps. We sample the same from the same locations once a year over three years (0, 1, and 2). Prevalence is not uniform within each region or over time. At baseline (year 0), prevalence varies between villages within each region around the mean for the region, and prevalence varies between sites within each village around the mean for the village.  Consequently though the prevalence is different for each site, two sites within the same village are likely to have a more similar prevalence than two sites in different villages, or two sites in different regions. On average the prevalence is declining over time (odds ratio of 0.8 per year), however, the growth rate varies between villages. Consequently two sites in different villages with similar prevalence at baseline may have different prevalence by the third year, and prevalence may go up in some villages. 

Each year the traps at each site catch a negative binomial number (mean 200, dispersion 5) of vectors. The catch size at each site and year is independent. Each year, the catches at each site are pooled into groups of 25 with an additional pool for any remainder (e.g. a catch of 53 vectors will be pooled into two pools of 25 and one pool of three). Each pool is tested for the marker of interest using a test with perfect sensitivity and specificity.

This synthetic dataset is provided with the package, and is the one used to illustrate the package in Boxes A and B. The predictions for each region and year, and for a sellection of villages are compared in Figure X and Y.

```{r AdditionalModelsForComparison, include = FALSE}
PrevsYearRegionVillage <- PoolPrev(ExampleData, Result, NumInPool,Region,Year,Village)

ModFreqVillage <- PoolReg(Result ~ Region + Year + Village,
                   ExampleData, NumInPool)

HierPrevsYearRegion <- HierPoolPrev(ExampleData, Result, NumInPool, c("Village", "Site"), Region, Year)
HierPrevsYearRegionVillage <- HierPoolPrev(ExampleData, Result, NumInPool, c("Site"), Region, Year, Village)
```



```{r HierComparisonRegion, echo=FALSE,warning = FALSE}
library(ggplot2)
RegionPO <- rbind(TruePrev %>%
                    select(Region, Year, Estimate = PrevalenceRegion) %>%
                    mutate(CILow = NA, CIHigh = NA, Method = 'True') %>%
                    unique(),
                  PrevsYearRegion %>%
                    select(Region, Year, Estimate = PrevMLE, CILow, CIHigh) %>%
                    mutate(Method = 'PoolPrev (Frequentist)'),
                  PrevsYearRegion %>%
                    select(Region, Year, Estimate = PrevBayes, CILow = CrILow, CIHigh = CrIHigh) %>%
                    mutate(Method = 'PoolPrev (Bayesian)'),
                  getPrevalence(ModFreq)$PopulationEffects %>%
                    mutate(Method = "PoolRegBayes"),
                  getPrevalence(ModBayesHier2)$PopulationEffects %>%
                    rename(CILow = CrILow, CIHigh = CrIHigh) %>%
                    mutate(Method = "PoolRegBayes (Adjusted for hierarchy)"),
                  HierPrevsYearRegion %>%
                    select(Region, Year, Estimate = PrevBayes, CILow = CrILow, CIHigh = CrIHigh) %>%
                    mutate(Method = "HierPoolPrev")) %>%
  mutate(Region = factor(paste0("Region ", Region), levels = paste0("Region ",c("C","B","A"))),
         Method = factor(Method, levels = c('PoolPrev (Frequentist)',
                                            'PoolPrev (Bayesian)',
                                            "HierPoolPrev",
                                            "PoolRegBayes",
                                            "PoolRegBayes (Adjusted for hierarchy)",
                                            "True"))) %>%
  unique() %>%
  ggplot(aes(x = Year, y = Estimate,
             ymin = CILow, ymax = CIHigh, shape = Method)) +
  geom_pointrange(position = position_dodge(width = 0.3)) +
  facet_grid(Region~.,scales = 'free_y') +
  scale_y_log10() +
  scale_x_continuous(breaks = 0:2) +
  ylab("Prevalence") +
  theme(text = element_text(size = 15),legend.position = "bottom") +
  guides(shape = guide_legend(override.aes = list(linetype = 0)))

RegionPO

```

```{r HierComparisonVillage, echo=FALSE, warning = FALSE}
VillagePO <- rbind(TruePrev %>%
                     select(Region, Year, Village, Estimate = PrevalenceVillage) %>%
                     mutate(CILow = NA, CIHigh = NA, Method = 'True'),
                   PrevsYearRegionVillage %>%
                     select(Region, Year, Village, Estimate = PrevMLE, CILow, CIHigh) %>%
                     mutate(Method = 'PoolPrev (frequentist)'),
                   PrevsYearRegionVillage %>%
                     select(Region, Year, Village, Estimate = PrevBayes, CILow = CrILow, CIHigh = CrIHigh) %>%
                     mutate(Method = 'PoolPrev (Bayesian)'),
                   getPrevalence(ModFreqVillage)$PopulationEffects %>%
                     mutate(Method = "PoolRegBayes",),
                   getPrevalence(ModBayesHier2)$Village %>%
                     rename(CILow = CrILow, CIHigh = CrIHigh) %>%
                     mutate(Method = "PoolRegBayes (adjusted for hierarchy)"),
                   HierPrevsYearRegionVillage %>%
                     select(Region, Year, Village, Estimate = PrevBayes, CILow = CrILow, CIHigh = CrIHigh) %>%
                     mutate(Method = "HierPoolPrev")) %>%
  mutate(Region = factor(Region, levels = c("C","B","A")),
         Method = factor(Method, levels = c('PoolPrev (frequentist)',
                                            'PoolPrev (Bayesian)',
                                            "HierPoolPrev",
                                            "PoolRegBayes",
                                            "PoolRegBayes (adjusted for hierarchy)",
                                            "True"))) %>%
  unique() %>%
  mutate(VillageNum = stringr::str_split_fixed(Village, pattern = "-", n= 2)[,2]) %>%
  subset(VillageNum %in% c(3,6,9)) %>%
  mutate(Village = paste0("Village ",VillageNum),
         Region = factor(paste0("Region ", Region), levels = paste0("Region ",c("C","B","A")))) %>%
  ggplot(aes(x = Year, y = Estimate,
             ymin = CILow, ymax = CIHigh, shape = Method)) +
  geom_pointrange(position = position_dodge(width = 0.6)) +
  facet_grid(Region~Village,scales = 'free_y') +
  scale_y_log10() +
  scale_x_continuous(breaks = 0:2) +
  ylab("Prevalence") +
  theme(text = element_text(size = 15),legend.position = "bottom") +
  guides(shape = guide_legend(override.aes = list(linetype = 0)))

```
